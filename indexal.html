<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Space Game - Phaser 3</title>
<style>
html,body { height:100%; margin:0; background:#000; color:#fff; font-family: monospace; }
#game { width:100%; height:100vh; overflow:hidden; position:relative; }
.pause-ui { position:absolute; top:50px; right:50px; display:flex; flex-direction:column; gap:8px; color:#fff; font-family: monospace; }
button,input { font-family: monospace; padding:4px 8px; background:#333; color:#fff; border:none; cursor:pointer; }
input[type=range], input[type=number] { width:150px; }
.highscores { font-size:14px; margin-top:10px; text-align:left; }
</style>
</head>
<body>
<div id="game"></div>
<div class="pause-ui" id="pause-ui" style="display:none;">
  <button id="mute-btn">ðŸ”Š</button>
  <label>Volume <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5"></label>
  <label>VelocitÃ  proiettili <input type="range" id="bullet-speed-slider" min="100" max="800" value="300"></label>
  <label>Postazioni fuoco <input type="number" id="gun-count" min="1" max="5" value="1"></label>
  <label>Dimensione esplosione <input type="range" id="explosion-scale-slider" min="0.5" max="3" step="0.1" value="1"></label>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const gameContainer = document.getElementById('game');
  const pauseUI = document.getElementById('pause-ui');
  const muteBtn = document.getElementById('mute-btn');
  const volumeSlider = document.getElementById('volume-slider');
  const bulletSpeedSlider = document.getElementById('bullet-speed-slider');
  const gunCountInput = document.getElementById('gun-count');
  const explosionScaleSlider = document.getElementById('explosion-scale-slider');

  // Crea canvas
  const canvas = document.createElement('canvas');
  canvas.style.display = 'block';
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.style.background = '#000';
  gameContainer.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  // Audio
  const shootSound = new Audio('assets/shoot.mp3');
  const hitSound = new Audio('assets/hit.mp3');
  const missSound = new Audio('assets/miss.mp3');
  const gameOverSound = new Audio('assets/gameover.mp3');
  // Stato variabili
  let dims = { w: 0, h: 0, base: 0, ship: 0, enemy: 0, bulletW: 0, bulletH: 0, bottomPad: 0 };
  let ship = { x: 0, y: 0, size: 0 };
  let bullets = [];
  let enemies = [];
  let explosions = [];
  let score = 0;
  let lives = 5;
  let lastShot = 0;
  let enemySpeedFactor = 1.0;
  const DIFFICULTY_STEP = 100;
  const SPEED_MULTIPLIER = 1.2;
  let enemySpawnTimer = 0;
  let paused = false;
  let gameOver = false;
  let keys = {};
  let pointerActive = false;
  let pointerX = 0;
  let pointerY = 0;
  // Config personalizzabili
  let bulletSpeed = parseInt(bulletSpeedSlider.value) || 300;
  let gunCount = parseInt(gunCountInput.value) || 1;
  let explosionScale = parseFloat(explosionScaleSlider.value) || 1.0;
  let globalVolume = parseFloat(volumeSlider.value) || 0.5;
  let muted = false;

  function updateVolume() {
    [shootSound, hitSound, missSound, gameOverSound].forEach(snd => {
      snd.volume = globalVolume;
      snd.muted = muted;
    });
  }
  updateVolume();

  function computeDims() {
    const w = gameContainer.clientWidth;
    const h = gameContainer.clientHeight;
    const base = Math.min(w, h);
    return {
      w, h, base,
      ship: base * 0.08,
      enemy: base * 0.10 * 3.0, // fattore ingrandimento nemico 3x
      bulletW: base * 0.02,
      bulletH: base * 0.04,
      bottomPad: Math.max(48, h * 0.08)
    };
  }

  function resize() {
    const prevW = dims.w;
    const prevH = dims.h;
    dims = computeDims();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = dims.w * ratio;
    canvas.height = dims.h * ratio;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(ratio, ratio);
    if (prevW && prevH) {
      const scaleX = dims.w / prevW;
      const scaleY = dims.h / prevH;
      ship.x *= scaleX;
      ship.y *= scaleY;
      bullets.forEach(b => { b.x *= scaleX; b.y *= scaleY; });
      enemies.forEach(e => { e.x *= scaleX; e.y *= scaleY; });
      explosions.forEach(ex => { ex.x *= scaleX; ex.y *= scaleY; ex.maxRadius = dims.enemy * explosionScale; });
    }
    ship.size = dims.ship;
    ship.y = dims.h - dims.bottomPad;
  }

  function init() {
    dims = computeDims();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = dims.w * ratio;
    canvas.height = dims.h * ratio;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(ratio, ratio);
    ship.size = dims.ship;
    ship.x = dims.w / 2;
    ship.y = dims.h - dims.bottomPad;
    bullets = [];
    enemies = [];
    explosions = [];
    score = 0;
    lives = 5;
    lastShot = 0;
    enemySpeedFactor = 1.0;
    enemySpawnTimer = 0;
    paused = false;
    gameOver = false;
    // Rimuove eventuale overlay game over
    const oldOverlay = document.getElementById('gameover-overlay');
    if (oldOverlay) oldOverlay.remove();
    pauseUI.style.display = 'none';
    updateVolume();
  }

  // Input tastiera
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyP') {
      togglePause();
    }
  });
  window.addEventListener('keyup', e => { keys[e.code] = false; });
  // Input pointer
  function pointerDown(e) {
    pointerActive = true;
    pointerX = e.touches ? e.touches[0].clientX : e.clientX;
    pointerY = e.touches ? e.touches[0].clientY : e.clientY;
  }
  function pointerMove(e) {
    if (pointerActive) {
      pointerX = e.touches ? e.touches[0].clientX : e.clientX;
      pointerY = e.touches ? e.touches[0].clientY : e.clientY;
    }
  }
  function pointerUp() { pointerActive = false; }
  canvas.addEventListener('mousedown', pointerDown);
  canvas.addEventListener('touchstart', pointerDown);
  canvas.addEventListener('mousemove', pointerMove);
  canvas.addEventListener('touchmove', pointerMove);
  canvas.addEventListener('mouseup', pointerUp);
  canvas.addEventListener('touchend', pointerUp);
  canvas.addEventListener('touchcancel', pointerUp);

  function spawnEnemy() {
    const x = Math.random() * (dims.w - dims.enemy) + dims.enemy / 2;
    const speed = (Math.random() * (dims.base * 0.08) + dims.base * 0.10) * enemySpeedFactor;
    enemies.push({ x, y: -dims.enemy, speed });
  }

  let lastTime = performance.now();
  function update(dt) {
    if (paused || gameOver) return;
    // Movimento nave
    const moveSpeed = dims.base * 0.8;
    if (keys['ArrowLeft'] || keys['KeyA']) ship.x -= moveSpeed * dt;
    if (keys['ArrowRight'] || keys['KeyD']) ship.x += moveSpeed * dt;
    if (keys['ArrowUp'] || keys['KeyW']) ship.y -= moveSpeed * dt;
    if (keys['ArrowDown'] || keys['KeyS']) ship.y += moveSpeed * dt;
    if (pointerActive) {
      ship.x = pointerX;
      ship.y = pointerY;
    }
    // Limiti nave
    const half = ship.size / 2;
    ship.x = Math.max(half, Math.min(dims.w - half, ship.x));
    ship.y = Math.max(half, Math.min(dims.h - dims.bottomPad, ship.y));
    // Spara
    const now = performance.now();
    const fireInput = keys['Space'] || pointerActive;
    if (fireInput && now > lastShot + 200) {
      const spread = 15;
      const halfShip = ship.size / 2;
      for (let i = 0; i < gunCount; i++) {
        const offset = (i - (gunCount - 1) / 2) * spread;
        bullets.push({ x: ship.x + offset, y: ship.y - halfShip, speed: bulletSpeed });
      }
      lastShot = now;
      shootSound.currentTime = 0;
      shootSound.play();
    }
    // Aggiorna proiettili
    bullets = bullets.filter(b => {
      b.y -= b.speed * dt;
      return b.y + dims.bulletH > 0;
    });
    // Aggiorna nemici e vite
    enemies = enemies.filter(e => {
      e.y += e.speed * dt;
      if (e.y - dims.enemy / 2 > dims.h) {
        lives--;
        missSound.currentTime = 0;
        missSound.play();
        if (lives <= 0) {
          triggerGameOver();
        }
        return false;
      }
      return true;
    });
    // Collisioni
    bullets.forEach((b, bi) => {
      enemies.forEach((e, ei) => {
        const dx = Math.abs(b.x - e.x);
        const dy = Math.abs(b.y - e.y);
        if (dx < (dims.bulletW + dims.enemy) / 2 && dy < (dims.bulletH + dims.enemy) / 2) {
          bullets[bi]._hit = true;
          enemies[ei]._hit = true;
          score++;
          if (score % DIFFICULTY_STEP === 0) {
            enemySpeedFactor *= SPEED_MULTIPLIER;
          }
          explosions.push({ x: e.x, y: e.y, radius: 0, maxRadius: dims.enemy * explosionScale, alpha: 1 });
          hitSound.currentTime = 0;
          hitSound.play();
        }
      });
    });
    bullets = bullets.filter(b => !b._hit);
    enemies = enemies.filter(e => !e._hit);
    // Aggiorna esplosioni
    explosions = explosions.filter(ex => {
      ex.radius += dims.base * 0.5 * dt;
      ex.alpha -= dt * 1.5;
      return ex.alpha > 0;
    });
    // Spawning nemici
    enemySpawnTimer += dt;
    if (enemySpawnTimer >= 0.7) {
      spawnEnemy();
      enemySpawnTimer = 0;
    }
  }
  function draw() {
    ctx.clearRect(0, 0, dims.w, dims.h);
    // Nave
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(ship.x - ship.size / 2, ship.y + ship.size / 2);
    ctx.lineTo(ship.x, ship.y - ship.size / 2);
    ctx.lineTo(ship.x + ship.size / 2, ship.y + ship.size / 2);
    ctx.closePath();
    ctx.fill();
    // Proiettili
    ctx.fillStyle = '#ffff00';
    bullets.forEach(b => {
      ctx.fillRect(b.x - dims.bulletW / 2, b.y - dims.bulletH / 2, dims.bulletW, dims.bulletH);
    });
    // Nemici
    ctx.fillStyle = '#ff4444';
    enemies.forEach(e => {
      ctx.beginPath();
      ctx.arc(e.x, e.y, dims.enemy / 2, 0, Math.PI * 2);
      ctx.fill();
    });
    // Esplosioni
    explosions.forEach(ex => {
      ctx.fillStyle = `rgba(255,165,0,${ex.alpha.toFixed(3)})`;
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
      ctx.fill();
    });
    // Punteggio e vite
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px monospace';
    ctx.textBaseline = 'top';
    ctx.textAlign = 'left';
    ctx.fillText('Score:' + score, 8, 8);
    ctx.fillText('Lives:' + lives, 8, 28);
    // Testo pausa
    if (paused && !gameOver) {
      ctx.fillStyle = '#ffff00';
      ctx.font = '32px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('PAUSE', dims.w / 2, dims.h / 2);
    }
  }
  function loop() {
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    if (!paused) update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  function togglePause() {
    if (gameOver) return;
    paused = !paused;
    pauseUI.style.display = paused ? 'flex' : 'none';
  }
  function triggerGameOver() {
    if (gameOver) return;
    gameOver = true;
    paused = true;
    gameOverSound.currentTime = 0;
    gameOverSound.play();
    // Overlay game over
    const overlay = document.createElement('div');
    overlay.id = 'gameover-overlay';
    overlay.style.position = 'absolute';
    overlay.style.top = 0;
    overlay.style.left = 0;
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    overlay.style.display = 'flex';
    overlay.style.flexDirection = 'column';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.color = '#fff';
    overlay.style.fontFamily = 'monospace';
    overlay.style.zIndex = 1000;
    // Testo e punteggio
    const goText = document.createElement('div');
    goText.textContent = 'GAME OVER';
    goText.style.fontSize = '32px';
    goText.style.color = '#ff4444';
    goText.style.marginBottom = '16px';
    overlay.appendChild(goText);
    const scoreDisplay = document.createElement('div');
    scoreDisplay.textContent = 'Score: ' + score;
    scoreDisplay.style.fontSize = '20px';
    scoreDisplay.style.marginBottom = '16px';
    overlay.appendChild(scoreDisplay);
    // Classifica top 10
    const KEY = 'phaser_highscores';
    let list = JSON.parse(localStorage.getItem(KEY) || '[]');
    list.push({ score: score, date: new Date().toISOString() });
    list.sort((a, b) => b.score - a.score);
    list = list.slice(0, 10);
    localStorage.setItem(KEY, JSON.stringify(list));
    const hs = document.createElement('div');
    hs.style.fontSize = '16px';
    hs.style.color = '#ffff00';
    hs.style.whiteSpace = 'pre';
    hs.style.textAlign = 'center';
    hs.textContent = 'Top 10:\n' + list.map((r, i) => `${i + 1}. ${r.score}`).join('\n');
    overlay.appendChild(hs);
    // Pulsante restart
    const restartBtn = document.createElement('button');
    restartBtn.textContent = 'Restart';
    restartBtn.style.marginTop = '20px';
    restartBtn.style.padding = '6px 12px';
    restartBtn.style.fontSize = '16px';
    restartBtn.style.backgroundColor = '#333';
    restartBtn.style.color = '#fff';
    restartBtn.style.border = 'none';
    restartBtn.style.cursor = 'pointer';
    restartBtn.onclick = () => {
      overlay.remove();
      init();
    };
    overlay.appendChild(restartBtn);
    document.body.appendChild(overlay);
  }
  // Gestione UI esterna
  volumeSlider.addEventListener('input', e => {
    globalVolume = parseFloat(e.target.value);
    updateVolume();
  });
  muteBtn.addEventListener('click', () => {
    muted = !muted;
    updateVolume();
    muteBtn.textContent = muted ? 'ðŸ”‡' : 'ðŸ”Š';
  });
  bulletSpeedSlider.addEventListener('input', e => {
    bulletSpeed = parseInt(e.target.value);
  });
  gunCountInput.addEventListener('input', e => {
    const val = parseInt(e.target.value);
    gunCount = Math.min(5, Math.max(1, val));
  });
  explosionScaleSlider.addEventListener('input', e => {
    explosionScale = parseFloat(e.target.value);
    explosions.forEach(ex => {
      ex.maxRadius = dims.enemy * explosionScale;
    });
  });
  window.addEventListener('resize', resize);
  // Preload audio (evita ritardi)
  [shootSound, hitSound, missSound, gameOverSound].forEach(snd => { snd.preload = 'auto'; });
  init();
  lastTime = performance.now();
  requestAnimationFrame(loop);
});
</script>

</body>
</html>
