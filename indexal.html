<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Phaser Resize Stable</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html,body { margin:0; height:100%; }
    #game { position:fixed; inset:0; }
  </style>
  <!-- Nessuna libreria esterna necessaria: il gioco è implementato con
       JavaScript puro usando l'elemento canvas. -->
</head>
<body>
<div id="game"></div>
<script>

// canvas e contesto di rendering
const container = document.getElementById('game');
const canvas = document.createElement('canvas');
canvas.style.display = 'block';
canvas.style.width = '100%';
canvas.style.height = '100%';
canvas.style.background = '#000';
container.appendChild(canvas);
const ctx = canvas.getContext('2d');

// stato di gioco
let ship = { x: 0, y: 0, size: 0 };
let bullets = [];
let enemies = [];
let lastShot = 0;
let score = 0;
let keys = {};
let pointerActive = false;
let pointerX = 0;
let lastTime = performance.now();
let dims = { w: 0, h: 0, base: 0, ship: 0, enemy: 0, bulletW: 0, bulletH: 0, bottomPad: 0 };

// Calcola le dimensioni in base alla finestra corrente
function computeDims() {
  const w = container.clientWidth;
  const h = container.clientHeight;
  const base = Math.min(w, h);
  return {
    w,
    h,
    base,
    ship: base * 0.08,
    enemy: base * 0.10,
    bulletW: base * 0.02,
    bulletH: base * 0.04,
    bottomPad: Math.max(48, h * 0.08)
  };
}

// Ridimensiona il canvas e scala gli oggetti esistenti proporzionalmente
function resize() {
  const prevW = dims.w;
  const prevH = dims.h;
  const prevDims = dims;
  dims = computeDims();
  // Aggiorna dimensioni del canvas tenendo conto del devicePixelRatio per nitidezza
  const ratio = window.devicePixelRatio || 1;
  canvas.width = dims.w * ratio;
  canvas.height = dims.h * ratio;
  // Reset trasformation per evitare scaling cumulativo
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(ratio, ratio);
  // Scala posizione di nave, proiettili ed altri oggetti se esisteva una dimensione precedente
  if (prevW && prevH) {
    const scaleX = dims.w / prevW;
    const scaleY = dims.h / prevH;
    ship.x *= scaleX;
    ship.y *= scaleY;
    bullets.forEach(b => {
      b.x *= scaleX;
      b.y *= scaleY;
    });
    enemies.forEach(e => {
      e.x *= scaleX;
      e.y *= scaleY;
    });
  }
  // Aggiorna grandezze
  ship.size = dims.ship;
  ship.y = dims.h - dims.bottomPad;
}

// Inizializza lo stato del gioco
function init() {
  dims = computeDims();
  const ratio = window.devicePixelRatio || 1;
  canvas.width = dims.w * ratio;
  canvas.height = dims.h * ratio;
  // Reset trasformazione e scala per il dispositivo corrente
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(ratio, ratio);
  ship.size = dims.ship;
  ship.x = dims.w / 2;
  ship.y = dims.h - dims.bottomPad;
  bullets = [];
  enemies = [];
  score = 0;
  lastShot = 0;
  lastTime = performance.now();
}

// Gestione tastiera
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Gestione pointer (mouse/touch)
function pointerDown(e) {
  pointerActive = true;
  pointerX = e.clientX || (e.touches && e.touches[0].clientX) || 0;
}
function pointerMove(e) {
  if (pointerActive) {
    pointerX = e.clientX || (e.touches && e.touches[0].clientX) || 0;
  }
}
function pointerUp() {
  pointerActive = false;
}
canvas.addEventListener('mousedown', pointerDown);
canvas.addEventListener('touchstart', pointerDown);
canvas.addEventListener('mousemove', pointerMove);
canvas.addEventListener('touchmove', pointerMove);
canvas.addEventListener('mouseup', pointerUp);
canvas.addEventListener('touchend', pointerUp);
canvas.addEventListener('touchcancel', pointerUp);

// Spawna un nemico alla sommità
function spawnEnemy() {
  const x = Math.random() * (dims.w - dims.enemy) + dims.enemy / 2;
  const speed = Math.random() * (dims.base * 0.08) + dims.base * 0.10;
  enemies.push({ x: x, y: -dims.enemy, speed: speed });
}

// Loop principale
function loop() {
  const now = performance.now();
  const dt = (now - lastTime) / 1000; // secondi trascorsi
  lastTime = now;
  // Aggiorna posizioni
  update(dt);
  // Disegna scena
  draw();
  requestAnimationFrame(loop);
}

// Aggiornamento logica di gioco
let enemySpawnTimer = 0;
function update(dt) {
  // Movimento nave con tastiera
  const moveSpeed = dims.base * 0.8;
  if (keys['ArrowLeft'] || keys['KeyA']) {
    ship.x -= moveSpeed * dt;
  }
  if (keys['ArrowRight'] || keys['KeyD']) {
    ship.x += moveSpeed * dt;
  }
  // Movimento con pointer
  if (pointerActive) {
    ship.x = pointerX;
  }
  // Clamp bordo
  const half = ship.size / 2;
  ship.x = Math.max(half, Math.min(dims.w - half, ship.x));
  // Sparo
  const now = performance.now();
  if ((keys['Space'] || pointerActive) && now > lastShot + 200) {
    bullets.push({ x: ship.x, y: ship.y - half, speed: dims.base * 0.9 });
    lastShot = now;
  }
  // Aggiorna proiettili
  bullets = bullets.filter(b => {
    b.y -= b.speed * dt;
    return b.y + dims.bulletH > 0;
  });
  // Aggiorna nemici
  enemies = enemies.filter(e => {
    e.y += e.speed * dt;
    return e.y - dims.enemy < dims.h + dims.enemy;
  });
  // Collisioni proiettile-nemico
  bullets.forEach((b, bi) => {
    enemies.forEach((e, ei) => {
      const distX = Math.abs(b.x - e.x);
      const distY = Math.abs(b.y - e.y);
      if (distX < (dims.bulletW + dims.enemy) / 2 && distY < (dims.bulletH + dims.enemy) / 2) {
        bullets[bi]._hit = true;
        enemies[ei]._hit = true;
        score++;
      }
    });
  });
  bullets = bullets.filter(b => !b._hit);
  enemies = enemies.filter(e => !e._hit);
  // Timer spawn nemici
  enemySpawnTimer += dt;
  if (enemySpawnTimer >= 0.7) {
    spawnEnemy();
    enemySpawnTimer = 0;
  }
}

// Disegna tutti gli elementi
function draw() {
  ctx.clearRect(0, 0, dims.w, dims.h);
  // Disegna nave (triangolo bianco)
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(ship.x - ship.size / 2, ship.y + ship.size / 2);
  ctx.lineTo(ship.x, ship.y - ship.size / 2);
  ctx.lineTo(ship.x + ship.size / 2, ship.y + ship.size / 2);
  ctx.closePath();
  ctx.fill();
  // Disegna proiettili (rettangoli gialli)
  ctx.fillStyle = '#ffff00';
  bullets.forEach(b => {
    ctx.fillRect(b.x - dims.bulletW / 2, b.y - dims.bulletH / 2, dims.bulletW, dims.bulletH);
  });
  // Disegna nemici (cerchi rossi)
  ctx.fillStyle = '#ff4444';
  enemies.forEach(e => {
    ctx.beginPath();
    ctx.arc(e.x, e.y, dims.enemy / 2, 0, Math.PI * 2);
    ctx.fill();
  });
  // Disegna punteggio
  ctx.fillStyle = '#ffffff';
  ctx.font = '16px monospace';
  ctx.textBaseline = 'top';
  ctx.fillText(score.toString(), 8, 8);
}

// Gestisce ridimensionamento della finestra
window.addEventListener('resize', () => {
  resize();
});

// Avvia il gioco
init();
requestAnimationFrame(loop);
</script>
</body>
</html>
