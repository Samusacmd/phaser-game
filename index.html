<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Space Game con astronave dimensione fissa</title>
<style>
html, body {
  height: 100%; margin: 0; background: #000; color: #fff; font-family: monospace; overflow: hidden;
}
#game {
  width: 100%; height: 100vh; overflow: hidden; position: relative;
}
.pause-ui {
  position: absolute; top: 50px; right: 50px; display: flex; flex-direction: column; gap: 8px; color: #fff; font-family: monospace;
}
button, input {
  font-family: monospace; padding: 4px 8px; background: #333; color: #fff; border:none; cursor:pointer;
}
input[type=range], input[type=number] {
  width: 150px;
}
#countdown-container {
  position: absolute;
  top: 30%;
  width: 100%;
  text-align: center;
  font-size: 48px;
  font-weight: bold;
  user-select: none;
  z-index: 2000;
  pointer-events: none;
}
#countdown-message {
  font-size: 28px;
  margin-bottom: 20px;
}
</style>
</head>
<body>
<div id="game"></div>
<div class="pause-ui" id="pause-ui" style="display:none;">
  <button id="mute-btn">🔊</button>
  <label>Volume effetti <input type="range" id="effects-volume-slider" min="0" max="1" step="0.01" value="0.5"/></label>
  <label>Volume musica <input type="range" id="music-volume-slider" min="0" max="1" step="0.01" value="0.5"/></label>
  <label>Velocità proiettili <input type="range" id="bullet-speed-slider" min="100" max="800" value="300"/></label>
  <label>Postazioni fuoco <input type="number" id="gun-count" min="1" max="10" value="1"/></label>
  <label>Dimensione esplosione <input type="range" id="explosion-scale-slider" min="0.5" max="3" step="0.1" value="1"/></label>
  <label>Distanza fra cannoni <input type="range" id="gun-distance-slider" min="10" max="80" value="28"/></label>
</div>

<div id="countdown-container" style="display:none;">
  <div id="countdown-message"></div>
  <div id="countdown-number"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const gameContainer = document.getElementById('game');
  const pauseUI = document.getElementById('pause-ui');
  const muteBtn = document.getElementById('mute-btn');
  const effectsVolSlider = document.getElementById('effects-volume-slider');
  const musicVolSlider = document.getElementById('music-volume-slider');
  const bulletSpeedSlider = document.getElementById('bullet-speed-slider');
  const gunCountInput = document.getElementById('gun-count');
  const explosionScaleSlider = document.getElementById('explosion-scale-slider');
  const gunDistanceSlider = document.getElementById('gun-distance-slider');

  const countdownContainer = document.getElementById('countdown-container');
  const countdownNumberEl = document.getElementById('countdown-number');
  const countdownMessageEl = document.getElementById('countdown-message');

  const countdownMessage = "Distruggi i Fabio prima che invadano l'universo";

  const pauseBtn = document.createElement('button');
  pauseBtn.textContent = "⏸";
  pauseBtn.style.position = "absolute";
  pauseBtn.style.top = "10px";
  pauseBtn.style.right = "10px";
  pauseBtn.style.zIndex = 1001;
  pauseBtn.style.fontSize = "26px";
  pauseBtn.style.backgroundColor = "#444";
  pauseBtn.style.color = "#fff";
  pauseBtn.style.borderRadius = "10px";
  pauseBtn.style.padding = "8px";
  gameContainer.appendChild(pauseBtn);

  const canvas = document.createElement('canvas');
  canvas.style.display = 'block';
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.style.background = '#000';
  gameContainer.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  const shipImg = new Image();
  shipImg.src = 'assets/ship.png';

  const monsterImg = new Image();
  monsterImg.src = 'assets/monster.png';

  const bulletImg = new Image();
  bulletImg.src = 'assets/bullet.png';

  const shootSound = new Audio('assets/shoot.mp3');
  const hitSound = new Audio('assets/hit.mp3');
  const missSound = new Audio('assets/miss.mp3');
  const gameOverSound = new Audio('assets/gameover.mp3');
  const bgMusic = new Audio('assets/background.mp3');
  bgMusic.loop = true;

  let dims = { w: 0, h: 0, base: 0, ship: 0, enemy: 0, bulletW: 0, bulletH: 0, bottomPad: 0 };
  let ship = { x: 0, y: 0, size: 0 };
  let bullets = [];
  let enemies = [];
  let explosions = [];
  let score = 0;
  let lives = 5;
  let lastShot = 0;
  let enemySpeedFactor = 1.0;
  const DIFFICULTY_STEP = 100;
  const SPEED_MULTIPLIER = 1.2;
  const CANNON_UP_STEP = 250;
  let enemySpawnTimer = 0;
  let paused = false;
  let gameOver = false;
  let keys = {};
  let pointerActive = false;
  let pointerX = 0;
  let pointerY = 0;

  let bulletSpeed = parseInt(bulletSpeedSlider.value) || 300;
  let gunCount = parseInt(gunCountInput.value) || 1;
  let gunDistance = parseInt(gunDistanceSlider.value) || 28;
  let explosionScale = parseFloat(explosionScaleSlider.value) || 1.0;
  let effectsVolume = parseFloat(effectsVolSlider.value) || 0.5;
  let musicVolume = parseFloat(musicVolSlider.value) || 0.5;
  let muted = false;
  let resumeDelay = 1.0;

  function updateVolume(){
    [shootSound, hitSound, missSound, gameOverSound].forEach(snd=>{
      snd.volume = effectsVolume;
      snd.muted = muted;
    });
    bgMusic.volume = musicVolume;
    bgMusic.muted = muted;
  }
  updateVolume();

  function computeDims(){
    const w = gameContainer.clientWidth;
    const h = gameContainer.clientHeight;
    const base = Math.min(w,h);
    return {
      w, h, base,
      ship: 500,          // FISSA la dimensione dell'astronave a 120 px
      enemy: base * 0.1 * 3.0,
      bulletW: base * 0.015,
      bulletH: base * 0.03,
      bottomPad: Math.max(48, h * 0.08)
    };
  }

  function resize(){
    const prevW = dims.w;
    const prevH = dims.h;
    dims = computeDims();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = dims.w * ratio;
    canvas.height = dims.h * ratio;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(ratio,ratio);
    if(prevW && prevH){
      const scaleX = dims.w / prevW;
      const scaleY = dims.h / prevH;
      ship.x *= scaleX;
      ship.y *= scaleY;
      bullets.forEach(b => { b.x *= scaleX; b.y *= scaleY });
      enemies.forEach(e => { e.x *= scaleX; e.y *= scaleY });
      explosions.forEach(ex => { ex.x *= scaleX; ex.y *= scaleY; ex.maxRadius = dims.enemy * explosionScale });
    }
    ship.size = dims.ship;
    ship.y = dims.h - dims.bottomPad;
  }

  function init(){
    dims = computeDims();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = dims.w * ratio;
    canvas.height = dims.h * ratio;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(ratio,ratio);
    ship.size = dims.ship;
    ship.x = dims.w / 2;
    ship.y = dims.h - dims.bottomPad;
    bullets = [];
    enemies = [];
    explosions = [];
    score = 0;
    lives = 5;
    lastShot = 0;
    enemySpeedFactor = 1.0;
    enemySpawnTimer = 0;
    paused = false;
    gameOver = false;
    gunCount = 1;
    gunCountInput.value = gunCount;
    const oldOverlay = document.getElementById('gameover-overlay');
    if(oldOverlay) oldOverlay.remove();
    pauseUI.style.display = 'none';
    updateVolume();
  }

  window.addEventListener('keydown', e=>{keys[e.code]=true});
  window.addEventListener('keyup', e=>{keys[e.code]=false});

  function pointerDown(e){
    pointerActive = true;
    pointerX = e.touches ? e.touches[0].clientX : e.clientX;
    pointerY = e.touches ? e.touches[0].clientY : e.clientY;
  }
  function pointerMove(e){
    if(pointerActive){
      pointerX = e.touches ? e.touches[0].clientX : e.clientX;
      pointerY = e.touches ? e.touches[0].clientY : e.clientY;
    }
  }
  function pointerUp(){pointerActive = false}
  canvas.addEventListener('mousedown', pointerDown);
  canvas.addEventListener('touchstart', pointerDown);
  canvas.addEventListener('mousemove', pointerMove);
  canvas.addEventListener('touchmove', pointerMove);
  canvas.addEventListener('mouseup', pointerUp);
  canvas.addEventListener('touchend', pointerUp);
  canvas.addEventListener('touchcancel', pointerUp);

  function spawnEnemy(){
    const x = Math.random()*(dims.w - dims.enemy) + dims.enemy/2;
    const speed = (Math.random()*(dims.base*0.08) + dims.base*0.1)*enemySpeedFactor;
    enemies.push({x, y:-dims.enemy, speed});
  }

  let lastTime = performance.now();

  function update(dt){
    if(paused || gameOver) return;
    const moveSpeed = dims.base * 0.8;
    if(keys['ArrowLeft']||keys['KeyA']) ship.x -= moveSpeed*dt;
    if(keys['ArrowRight']||keys['KeyD']) ship.x += moveSpeed*dt;
    if(keys['ArrowUp']||keys['KeyW']) ship.y -= moveSpeed*dt;
    if(keys['ArrowDown']||keys['KeyS']) ship.y += moveSpeed*dt;
    if(pointerActive){
      ship.x = pointerX;
      ship.y = pointerY;
    }
    const half = ship.size/2;
    ship.x = Math.max(half, Math.min(dims.w - half, ship.x));
    ship.y = Math.max(half, Math.min(dims.h - dims.bottomPad, ship.y));
    const now = performance.now();
    const fireInput = keys['Space'] || pointerActive;
    if(fireInput && now > lastShot + 200){
      const spread = gunDistance;
      const halfShip = ship.size/2;
      for(let i=0; i < gunCount; i++){
        const offset = (i - (gunCount - 1)/2)*spread;
        bullets.push({x: ship.x + offset, y: ship.y - halfShip, speed: bulletSpeed});
      }
      lastShot = now;
      shootSound.currentTime = 0;
      shootSound.play();
    }
    bullets = bullets.filter(b=>{
      b.y -= b.speed*dt;
      return b.y + dims.bulletH > 0;
    });
    enemies = enemies.filter(e=>{
      e.y += e.speed*dt;
      if(e.y - dims.enemy/2 > dims.h){
        lives--;
        missSound.currentTime = 0;
        missSound.play();
        if(lives <= 0) triggerGameOver();
        return false;
      }
      return true;
    });
    bullets.forEach((b, bi)=>{
      enemies.forEach((e, ei)=>{
        const dx = Math.abs(b.x - e.x);
        const dy = Math.abs(b.y - e.y);
        if(dx < (dims.bulletW + dims.enemy)/2 && dy < (dims.bulletH + dims.enemy)/2){
          bullets[bi]._hit = true;
          enemies[ei]._hit = true;
          score++;
          if(score % DIFFICULTY_STEP === 0) enemySpeedFactor *= SPEED_MULTIPLIER;
          if(score % CANNON_UP_STEP === 0 && gunCount < 3){
            gunCount++;
            gunCountInput.value = gunCount;
          }
          explosions.push({x: e.x, y: e.y, radius: 0, maxRadius: dims.enemy * explosionScale, alpha: 1});
          hitSound.currentTime = 0;
          hitSound.play();
        }
      });
    });
    bullets = bullets.filter(b=>!b._hit);
    enemies = enemies.filter(e=>!e._hit);
    explosions = explosions.filter(ex=>{
      ex.radius += dims.base * 0.5 * dt;
      ex.alpha -= dt * 1.5;
      return ex.alpha > 0;
    });
    enemySpawnTimer += dt;
    if(enemySpawnTimer >= 0.7){
      spawnEnemy();
      enemySpawnTimer = 0;
    }
  }

  function draw(){
    ctx.clearRect(0, 0, dims.w, dims.h);

    if(shipImg.complete){
      ctx.drawImage(shipImg,
        ship.x - ship.size/2,
        ship.y - ship.size/2,
        ship.size,
        ship.size
      );
    } else {
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(ship.x - ship.size/2, ship.y + ship.size/2);
      ctx.lineTo(ship.x, ship.y - ship.size/2);
      ctx.lineTo(ship.x + ship.size/2, ship.y + ship.size/2);
      ctx.closePath();
      ctx.fill();
    }

    if(bulletImg.complete){
      bullets.forEach(b => {
        ctx.drawImage(bulletImg,
          b.x - dims.bulletW/2,
          b.y - dims.bulletH/2,
          dims.bulletW,
          dims.bulletH);
      });
    } else {
      ctx.fillStyle = '#ff0';
      bullets.forEach(b => {
        ctx.fillRect(
          b.x - dims.bulletW/2,
          b.y - dims.bulletH/2,
          dims.bulletW,
          dims.bulletH
        );
      });
    }

    enemies.forEach(e => {
      if(monsterImg.complete){
        ctx.drawImage(monsterImg, e.x - dims.enemy/2, e.y - dims.enemy/2, dims.enemy, dims.enemy);
      } else {
        ctx.fillStyle = '#f44';
        ctx.beginPath();
        ctx.arc(e.x, e.y, dims.enemy/2, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    explosions.forEach(ex => {
      ctx.fillStyle = `rgba(255,165,0,${ex.alpha.toFixed(3)})`;
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.fillStyle = '#fff';
    ctx.font = '16px monospace';
    ctx.textBaseline = 'top';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + score, 8, 8);
    ctx.fillText('Lives: ' + lives, 8, 28);

    if(paused && !gameOver){
      ctx.fillStyle = '#ff0';
      ctx.font = '32px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('PAUSA', dims.w/2, dims.h/2);
    }
  }

  function loop(){
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    if(!paused) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function togglePause(){
    if(gameOver) return;
    if(!paused){
      paused = true;
      pauseUI.style.display = 'flex';
      pauseBtn.style.backgroundColor = '#666';
      [shootSound, hitSound, missSound, gameOverSound].forEach(snd => snd.pause());
      return;
    }
    pauseUI.style.display = 'none';
    pauseBtn.style.backgroundColor = '#444';
    setTimeout(() => {
      paused = false;
      lastTime = performance.now();
      if(!muted && bgMusic.paused){
        bgMusic.play().catch(() => {});
      }
    }, resumeDelay * 1000);
  }

  function triggerGameOver(){
    if(gameOver) return;
    gameOver = true;
    paused = true;
    gameOverSound.currentTime = 0;
    gameOverSound.play();

    const overlay = document.createElement('div');
    overlay.id = 'gameover-overlay';
    overlay.style.position = 'absolute';
    overlay.style.top = 0;
    overlay.style.left = 0;
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
    overlay.style.display = 'flex';
    overlay.style.flexDirection = 'column';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.color = '#fff';
    overlay.style.fontFamily = 'monospace';
    overlay.style.zIndex = 1000;

    const goText = document.createElement('div');
    goText.textContent = 'GAME OVER';
    goText.style.fontSize = '32px';
    goText.style.color = '#ff4444';
    goText.style.marginBottom = '16px';
    overlay.appendChild(goText);

    const scoreDisplay = document.createElement('div');
    scoreDisplay.textContent = 'Score: ' + score;
    scoreDisplay.style.fontSize = '20px';
    scoreDisplay.style.marginBottom = '16px';
    overlay.appendChild(scoreDisplay);

    const KEY = 'phaser_highscores';
    let list = JSON.parse(localStorage.getItem(KEY) || '[]');
    list.push({score: score, date: new Date().toISOString()});
    list.sort((a,b) => b.score - a.score);
    list = list.slice(0, 10);
    localStorage.setItem(KEY, JSON.stringify(list));

    const hs = document.createElement('div');
    hs.style.fontSize = '16px';
    hs.style.color = '#ffff00';
    hs.style.whiteSpace = 'pre';
    hs.style.textAlign = 'center';
    hs.textContent = 'Top 10:\n' + list.map((r,i) => `${i+1}. ${r.score}`).join('\n');
    overlay.appendChild(hs);

    const restartBtn = document.createElement('button');
    restartBtn.textContent = 'Restart';
    restartBtn.style.marginTop = '20px';
    restartBtn.style.padding = '6px 12px';
    restartBtn.style.fontSize = '16px';
    restartBtn.style.backgroundColor = '#333';
    restartBtn.style.color = '#fff';
    restartBtn.style.border = 'none';
    restartBtn.style.cursor = 'pointer';
    restartBtn.onclick = () => {
      overlay.remove();
      init();
      startCountdown();
    };
    overlay.appendChild(restartBtn);

    document.body.appendChild(overlay);
    pauseBtn.style.display = '';
  }

  effectsVolSlider.addEventListener('input', e => {
    effectsVolume = parseFloat(e.target.value);
    updateVolume();
  });
  musicVolSlider.addEventListener('input', e => {
    musicVolume = parseFloat(e.target.value);
    updateVolume();
  });
  muteBtn.addEventListener('click', () => {
    muted = !muted;
    updateVolume();
    muteBtn.textContent = muted ? '🔇' : '🔊';
    if(muted){
      bgMusic.pause();
    } else {
      bgMusic.play().catch(() => {});
    }
  });
  bulletSpeedSlider.addEventListener('input', e => {
    bulletSpeed = parseInt(e.target.value);
  });
  gunCountInput.addEventListener('input', e => {
    const val = parseInt(e.target.value);
    gunCount = Math.min(10, Math.max(1, val));
    gunCountInput.value = gunCount;
  });
  explosionScaleSlider.addEventListener('input', e => {
    explosionScale = parseFloat(e.target.value);
    explosions.forEach(ex => ex.maxRadius = dims.enemy * explosionScale);
  });
  gunDistanceSlider.addEventListener('input', e => {
    gunDistance = parseInt(e.target.value);
  });

  pauseBtn.onclick = togglePause;
  window.addEventListener('resize', resize);

  [shootSound, hitSound, missSound, gameOverSound, bgMusic].forEach(snd => snd.preload = 'auto');

  function startCountdown(){
    countdownContainer.style.display = 'block';
    countdownMessageEl.textContent = countdownMessage;
    let count = 3;
    countdownNumberEl.textContent = count;
    paused = true;
    const intervalId = setInterval(() =>{
      count--;
      if(count === 0){
        clearInterval(intervalId);
        countdownContainer.style.display = 'none';
        paused = false;
        lastTime = performance.now();
        if(!muted) bgMusic.play().catch(() => {});
      } else {
        countdownNumberEl.textContent = count;
      }
    }, 1000);
  }

  init();
  resize();
  lastTime = performance.now();
  startCountdown();
  requestAnimationFrame(loop);
});
</script>
</body>
</html>
